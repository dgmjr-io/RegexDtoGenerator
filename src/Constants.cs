using System.Security.AccessControl;

/*
 * Constants.cs
 *
 *   Created: 2022-12-28-04:55:15
 *   Modified: 2022-12-28-04:55:17
 *
 *   Author: David G. Mooore, Jr. <david@dgmjr.io>
 *
 *   Copyright Â© 2022-2023 David G. Mooore, Jr., All Rights Reserved
 *      License: MIT (https://opensource.org/licenses/MIT)
 */

namespace Dgmjr.RegexDtoGenerator;

public static partial class Constants
{
    public const string DateFormat = "yyyy-MM-dd";
    public const string RegexDtoGenerator = "RegexDtoGenerator";
    public const string RegexDtoGeneratorVersion = ThisAssembly.Info.Version;
    public const string RegexDtoGeneratorDescription =
        "Generates a C# type from a regular expression.";
    public const string RegexDtoGeneratorHelpText =
        "Generates a C# type from a regular expression.";
    public const string RegexDtoGeneratorHelpTextExample =
        "Example: RegexDtoGenerator -r \"(?<Name>\\w+) (?<Age>\\d+)\" -n Person";
    public const string RegexDtoGeneratorHelpTextExample2 =
        "Example: RegexDtoGenerator -r \"(?<Name>\\w+) (?<Age>\\d+)\" -n Person -o \"C:\\Users\\Justin\\Documents\\Person.cs\"";
    public const string RegexDtoGeneratorHelpTextExample3 =
        "Example: RegexDtoGenerator -r \"(?<Name>\\w+) (?<Age>\\d+)\" -n Person -o \"C:\\Users\\Justin\\Documents\\Person.cs\" -p \"Dgmjr.erator\"";
    public const string RegexDtoGeneratorHelpTextExample4 =
        "Example: RegexDtoGenerator -r \"(?<Name>\\w+) (?<Age>\\d+)\" -n Person -o \"C:\\Users\\Justin\\Documents\\Person.cs\" -p \"Dgmjr.erator\" -c \"PersonDto\"";
    public const string RegexDtoGeneratorHelpTextExample5 =
        "Example: RegexDtoGenerator -r \"(?<Name>\\w+) (?<Age>\\d+)\" -n Person -o \"C:\\Users\\Justin\\Documents\\Person.cs\" -p \"Dgmjr.erator\" -c \"PersonDto\" -i";
    public const string RegexDtoGeneratorHelpTextExample6 =
        "Example: RegexDtoGenerator -r \"(?<Name>\\w+) (?<Age>\\d+)\" -n Person -o \"C:\\Users\\Justin\\Documents\\Person.cs\" -p \"Dgmjr.erator\" -c \"PersonDto\" -i -s";

    /// <value>RegexDtoAttribute</value>
    public const string RegexDtoAttributeName = "RegexDtoAttribute";

    /// <summary><inheritdoc cref="ThisAssembly.Project.AssemblyName" path="/summary" /></summary>
    /// <value>This<inheritdoc cref="ThisAssembly.Project.AssemblyName" path="/summary" /></value>
    public const string ThisAssemblyName = ThisAssembly.Project.AssemblyName;

    public const string Header = $$$$""""
    /*
     * <auto-generated />
     * This file was generated by "{{{{ThisAssemblyName}}}}".
     * {{ file_name }}
     *
     *   Created: {{ created_date }}
     */
    using static System.AttributeTargets;
    using static System.Text.RegularExpressions.RegexOptions;
    using System;
    using System.CodeDom.Compiler;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.Linq;
    using System.Runtime.CompilerServices;
    using System.Text;
    using System.Text.RegularExpressions;
    using static System.Text.RegularExpressions.RegexOptions;
    #if NET7_0_OR_GREATER
    using SS = System.Diagnostics.CodeAnalysis.StringSyntaxAttribute;
    #endif

    #nullable enable

    """";

    public const string RegexDtoAttributeDeclaration = $$$""""

    [AttributeUsage(@Class | @Struct, Inherited = false, AllowMultiple = false)]
[GeneratedCode("{{{ThisAssemblyName}}}", "{{{RegexDtoGeneratorVersion}}}"), CompilerGenerated]
/// <summary>Instantiate a new <see cref="RegexDtoAttribute">attribute</see></summary>
/// <param name="regex">The regex string to use to recognize/validate the DTO</param>
/// <param name="baseType">The type to inherit from (only valid on class definitions)</param>
/// <param name="regexOptions">The <see cref="RegexOptions" /> to use when parsing the <paramref name="regex">regex string</paramref></param>
internal sealed class RegexDtoAttribute(
#if NET7_0_OR_GREATER
        [StringSyntax(SS.Regex)]
#endif
        string Regex, System.Type? BaseType = null, RegexOptions RegexOptions = RegexOptions.Compiled | RegexOptions.CultureInvariant | RegexOptions.ExplicitCapture | RegexOptions.IgnoreCase | RegexOptions.IgnorePatternWhitespace | RegexOptions.Singleline) : System.Attribute
    {
    }
"""";

public const string RegexDtoAttributeUsage = """"
[RegexDto(@""(?< Name >\\w +)(?< Age >\\d +)"")]
    public class PersonDto
{
    public string Name { get; set; }
    public int Age { get; set; }
}
"""";

public const string RegexDtoBaseTypeDeclaration = $$$""""

    namespace {{ namespace_name }}
    {
    [GeneratedCode("{{{{ThisAssemblyName}}}}", "{{{{RegexDtoGeneratorVersion}}}}"), CompilerGenerated]
    { { ~visibility } }
    partial abstract
{ { target_data_structure_type } }
{ { type_name } }
Base
{ { if base_type != "" } } : { { base_type ~} }
{ { end } }
{
    /// <summary>The default <see cref="RegexOptions" /></summary>
    /// <value>(RegexOptions)({{ regex_options | string.replace ","  " | " }})</value>
    const RegexOptions RegexOptions = (RegexOptions)({ { regex_options | string.replace ","  " | " } });

            #if NET7_0_OR_GREATER
            [StringSyntax(SS.Regex)]
#endif
public const string RegexString = @"""{{ regex }}""";
// #if NET7_0_OR_GREATER
// [GeneratedRegex(RegexString, RegexOptions)]
// public static partial Regex Regex();
// #else
private static readonly System.Text.RegularExpressions.Regex _regex = new System.Text.RegularExpressions.Regex(RegexString, RegexOptions);
/// <summary>The <see cref="System.Text.RegularExpressions.Regex" /> that will be used to validate and recognize the DTO</summary>
public static System.Text.RegularExpressions.Regex Rgex() => _regex;
// #endif

{ { members } }
        }

        protected
{ { type_name } }
Base()
        {
}
    }

    """";

public const string RegexDtoTypeDeclaration = $$$$""""

    namespace {{ namespace_name }}
    {
    [System.CodeDom.Compiler.GeneratedCode("{{{{ThisAssemblyName}}}}", "{{{{RegexDtoGeneratorVersion}}}}")]
    { { visibility } }
    partial { { target_data_structure_type } }
    { { type_name } }
    { { if base_type != "" } } : { { base_type ~} }
    { { end } }
    {
        const RegexOptions RegexOptions = (RegexOptions)({ { regex_options | string.replace "," " | " } });

            public string OriginalString { get; init; }

#if NET7_0_OR_GREATER
            [StringSyntax(SS.Regex)]
#endif
/// <summary>The regex string that will be used to validate and recognize the DTO</summary>
public const string RegexString = @"{{ regex }}";

// #if NET7_0_OR_GREATER
// [GeneratedRegex(RegexString, RegexOptions)]
// public static partial System.Text.RegularExpressions.Regex Regex();
// #else
private static readonly System.Text.RegularExpressions.Regex _regex = new System.Text.RegularExpressions.Regex(RegexString, RegexOptions);

/// <summary>The <see cref="System.Text.RegularExpressions.Regex" /> that will be used to validate and recognize the DTO</summary>
public static
{ { if base_type != "" } }
new {{ end }} System.Text.RegularExpressions.Regex Regex() => _regex;
// #endif

{ { members } }
        }
    }

    """";

public const string RegexDtoParseDeclaration = """
    /// <summary>Parses the <paramref name="s">string</paramref> into an instance of <see cref="{{ type_name }}">the DTO</see></summary>
    /// <param name="s">The <see langword="string" /> to parse</param>
    /// <returns>The parsed <see cref="{{ type_name }}">DTO<see></returns>
public static
{ { type_name } }
Parse(string s)
    {
    return new {{ type_name }
} (s);
    }
    """;
    public const string RegexDtoConstructorDeclaration = """
    /// <summary>Instantiates a new, empty <see cref="{{ type_name }}">DTO</see></summary>
    { { parameterless_constructor_visibility } }
{ { type_name } } () { }

/// <summary>Instantiates a new <see cref="{{ type_name }}">DTO</see> and parses the <paramref name="s">string</paramref></summary>
{ { parameterized_constructor_visibility } }
{ { type_name } } (string s)
    {
    var match = Regex().Match(s);
    if (!match.Success)
    {
        throw new System.ArgumentException($"The string \"{s}\" does not match the regular expression \"{RegexString}\".", nameof(s));
    }

    { { ~ for property in properties ~} }
    { { ~ if property.is_nullable ~} }
    { { property.name } } = string.IsNullOrEmpty(match.Groups["{{ property.name }}"]?.Value) ? null : ({ { property.type } }?)System.Convert.ChangeType(match.Groups["{{ property.name }}"]?.Value, typeof({ { property.type } }));
    { { ~ else ~} }
    { { property.name } } = ({ { property.type } })System.Convert.ChangeType(match.Groups["{{ property.name }}"]?.Value, typeof({ { property.type } }));
    { { ~end ~} }
    { { ~end ~} }

    OriginalString = s;
}
""";

    public const string RegexDtoPropertiesDeclaration = """
    { { ~ for property in properties ~} }
{ { ~ if property.is_nullable ~} }
public
{ { property.overridability } }
{ { property.type } }?
{ { property.name } }
{ get; set; }
{ { ~ else ~} }
public
{ { property.overridability } }
{ { property.type } }
{ { property.name } }
{ get; set; }
{ { ~end ~} }
{ { ~end ~} }
""";

    public static readonly Scriban.Template RegexDtoDeclarationTemplate = Scriban.Template.Parse(
        RegexDtoTypeDeclaration,
        nameof(RegexDtoTypeDeclaration)
    );
public static readonly Scriban.Template RegexDtoParseDeclarationTemplate =
    Scriban.Template.Parse(RegexDtoParseDeclaration, nameof(RegexDtoParseDeclaration));
public static readonly Scriban.Template RegexDtoPropertiesDeclarationTemplate =
    Scriban.Template.Parse(
        RegexDtoPropertiesDeclaration,
        nameof(RegexDtoPropertiesDeclaration)
    );
public static readonly Scriban.Template RegexDtoConstructorDeclarationTemplate =
    Scriban.Template.Parse(
        RegexDtoConstructorDeclaration,
        nameof(RegexDtoConstructorDeclaration)
    );
public static readonly Scriban.Template RegexDtoAttributeDeclarationTemplate =
    Scriban.Template.Parse(RegexDtoAttributeDeclaration, nameof(RegexDtoAttributeDeclaration));
public static readonly Scriban.Template HeaderTemplate = Scriban.Template.Parse(
    Header,
    nameof(Header)
);
}
