/*
 * Constants.cs
 *
 *   Created: 2022-12-28-04:55:15
 *   Modified: 2022-12-28-04:55:17
 *
 *   Author: David G. Moore, Jr. <david@dgmjr.io>
 *
 *   Copyright Â© 2022-2023 David G. Moore, Jr., All Rights Reserved
 *      License: MIT (https://opensource.org/licenses/MIT)
 */

namespace Dgmjr.RegexDtoGenerator;

using Scriban;
using static Scriban.Template;

public static partial class Constants
{
    public const string DateFormat = "yyyy-mm-ddTHH:mm:ss.ffffzzzZ";
    public const string RegexDtoGenerator = nameof(RegexDtoGenerator);
    public const string RegexDtoGeneratorVersion = ThisAssembly.Info.Version;
    public const string RegexDtoAttributeName = "RegexDtoAttribute";
    public const string ThisAssemblyName = ThisAssembly.Project.AssemblyName;

    public const string Header = $$$$""""
    /*
     * <auto-generated>
     * This file was auto-generated by {{{{ThisAssemblyName}}}}, version {{{{RegexDtoGeneratorVersion}}}}.
     * {{ file_name }}
     *
     *    Created: {{ created_date }}
     *
     *      Changes to this file may cause incorrect behavior and will be lost if
     *      the code is regenerated.
     * </auto-generated>
     */
    using static System.AttributeTargets;
    using static System.Text.RegularExpressions.RegexOptions;
    using System;
    using System.CodeDom.Compiler;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.Linq;
    using System.Runtime.CompilerServices;
    using System.Text;
    using System.Text.RegularExpressions;
    using static System.Text.RegularExpressions.RegexOptions;
    #if NET7_0_OR_GREATER
    using SS = System.Diagnostics.CodeAnalysis.StringSyntaxAttribute;
    #endif

    #nullable enable

    """";

    public const string GeneratedCodeAttributesList =
        $"[GeneratedCode(\"{ThisAssemblyName}\", \"{RegexDtoGeneratorVersion}\"), CompilerGenerated]";

public const string RegexDtoAttributeDeclaration = $$$""""
    [AttributeUsage(@Class | @Struct, Inherited = false, AllowMultiple = false)]
    {{{GeneratedCodeAttributesList
}}}
    internal sealed class RegexDtoAttribute(
#if NET7_0_OR_GREATER
        [StringSyntax(SS.Regex)]
#endif
        string Regex, System.Type ? BaseType = null, RegexOptions RegexOptions = RegexOptions.Compiled | RegexOptions.CultureInvariant | RegexOptions.ExplicitCapture | RegexOptions.IgnoreCase | RegexOptions.IgnorePatternWhitespace | RegexOptions.Singleline) : System.Attribute
    {
}
"""";

public const string RegexDtoBaseTypeDeclaration = $$$""""
    namespace {{ namespace_name }}
    {
    { { { GeneratedCodeAttributesList} } }
    { { ~visibility } }
    partial abstract
{ { target_data_structure_type } }
{ { type_name } }
Base
{ { if base_type != "" } } : { { base_type ~} }
{ { end } }
{
    /// <summary>The default <see cref="RegexOptions" /></summary>
    /// <value>(RegexOptions)({{ regex_options | string.replace ","  " | " }})</value>
    const RegexOptions RegexOptions = (RegexOptions)({ { regex_options | string.replace ","  " | " } });

            #if NET7_0_OR_GREATER
            [StringSyntax(SS.Regex)]
#endif
public const string RegexString = @"""{{ regex }}""";

#if NET7_0_OR_GREATER
            [GeneratedRegex(RegexString, RegexOptions)]
            public static partial Regex Regex();
#else
private static readonly Regex _regex = new(RegexString, RegexOptions);
/// <summary>The <see cref="Regex" /> that will be used to validate and recognize the DTO</summary>
public static Regex Regex() => _regex;
#endif

{ { members } }
        }

        protected
{ { type_name } }
Base()
        {
}
    }
    """";

public const string RegexDtoTypeDeclaration = $$$$""""
    namespace {{ namespace_name }}
    {
    { { { { GeneratedCodeAttributesList} } } }
    { { visibility } }
    partial { { target_data_structure_type } }
    { { type_name } }
    { { if base_type != "" } } : { { base_type ~} }
    { { end } }
    {
        const RegexOptions RegexOptions = (RegexOptions)({ { regex_options | string.replace "," " | " } });

            public string OriginalString { get; init; }

#if NET7_0_OR_GREATER
            [StringSyntax(SS.Regex)]
#endif
/// <summary>The regex string that will be used to validate and recognize the DTO</summary>
public const string RegexString = @"{{ regex }}";

#if NET7_0_OR_GREATER
            [GeneratedRegex(RegexString, RegexOptions)]
            public static partial Regex Regex();
#else
private static readonly Regex _regex = new(RegexString, RegexOptions);
/// <summary>The <see cref="Regex" /> that will be used to validate and recognize the DTO</summary>
public static
{ { if base_type != "" } }
new {{ end }} Regex Regex() => _regex;
#endif

{ { members } }
        }
    }
    """";

public const string RegexDtoParseDeclaration = """
    /// <summary>Parses the <paramref name="s">string</paramref> into an instance of <see cref="{{ type_name }}">the DTO</see></summary>
    /// <param name="s">The <see langword="string" /> to parse</param>
    /// <returns>The parsed <see cref="{{ type_name }}">DTO<see></returns>
public static
{ { type_name } }
Parse(string s)
    {
    return new {{ type_name }
} (s);
    }
    """;

    public const string RegexDtoConstructorDeclaration = """
    /// <summary>Instantiates a new, empty <see cref="{{ type_name }}">DTO</see></summary>
    { { parameterless_constructor_visibility } }
{ { type_name } } () { }

/// <summary>Instantiates a new <see cref="{{ type_name }}">DTO</see> and parses the <paramref name="s">string</paramref></summary>
{ { parameterized_constructor_visibility } }
{ { type_name } } (string s)
    {
    var match = Regex().Match(s);
    if (!match.Success)
    {
        throw new ArgumentException($"The string \"{s}\" does not match the regular expression \"{RegexString}\".", nameof(s));
    }

    { { ~ for property in properties ~} }
    { { ~ if property.is_nullable ~} }
    { { property.name } } = string.IsNullOrEmpty(match.Groups["{{ property.name }}"]?.Value) ? null : ({ { property.type } }?)System.Convert.ChangeType(match.Groups["{{ property.name }}"]?.Value, typeof({ { property.type } }));
    { { ~ else ~} }
    { { property.name } } = ({ { property.type } })System.Convert.ChangeType(match.Groups["{{ property.name }}"]?.Value, typeof({ { property.type } }));
    { { ~end ~} }
    { { ~end ~} }

    OriginalString = s;
}
""";

    public const string RegexDtoPropertiesDeclaration = """
    { { ~ for property in properties ~} }
{ { ~ if property.is_nullable ~} }
public
{ { property.overridability } }
{ { property.type } }?
{ { property.name } }
{ get; set; }
{ { ~ else ~} }
public
{ { property.overridability } }
{ { property.type } }
{ { property.name } }
{ get; set; }
{ { ~end ~} }
{ { ~end ~} }
""";

    public static readonly Template RegexDtoDeclarationTemplate = Parse(
        RegexDtoTypeDeclaration,
        nameof(RegexDtoTypeDeclaration)
    );

public static readonly Template RegexDtoParseDeclarationTemplate = Parse(
    RegexDtoParseDeclaration,
    nameof(RegexDtoParseDeclaration)
);

public static readonly Template RegexDtoPropertiesDeclarationTemplate = Parse(
    RegexDtoPropertiesDeclaration,
    nameof(RegexDtoPropertiesDeclaration)
);

public static readonly Template RegexDtoConstructorDeclarationTemplate = Parse(
    RegexDtoConstructorDeclaration,
    nameof(RegexDtoConstructorDeclaration)
);

public static readonly Template RegexDtoAttributeDeclarationTemplate = Parse(
    RegexDtoAttributeDeclaration,
    nameof(RegexDtoAttributeDeclaration)
);

public static readonly Template HeaderTemplate = Parse(Header, nameof(Header));
}
